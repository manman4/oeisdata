%I A080768 #20 Sep 30 2025 14:57:18
%S A080768 2,3,14,35,3,22,242,23,253,13,155,12,3,77,5,4,65,860,3,10882,14,91,13,
%T A080768 5,80,543,946,25,1350,13,190,16,85,1575,865,82,8130,989,1425,65,209,
%U A080768 862,43608,26,192,5665,148,968,23632,17,6,41,8,294,27,828,1359,6,4,11
%N A080768 A unitary phi reciprocal amicable number: consider two different numbers r, s which satisfy the following equation for some integer k: uphi(r) = uphi(s) = (1/k) * r * s / (r-s); or equivalently, 1/uphi(r) = 1/uphi(s) = k * (1/s - 1/r); sequence gives k numbers.
%C A080768 Here uphi(n) = A047994(n) is the unitary totient function: if n = Product p_i^e_i, uphi(n) = Product (p_i^e_i - 1).
%C A080768 Sorted by increasing r, then increasing s. - _Sean A. Irvine_, Sep 29 2025
%H A080768 Michael S. Branicky, <a href="/A080768/b080768.txt">Table of n, a(n) for n = 1..66</a>
%o A080768 (Python)
%o A080768 from math import prod
%o A080768 from sympy import factorint
%o A080768 from itertools import count, islice
%o A080768 def uphi(n): return prod(p_i**e_i-1 for p_i, e_i in factorint(n).items())
%o A080768 def agen(): # generator of terms
%o A080768     uphi_level_sets = dict()
%o A080768     for r in count(1):
%o A080768         v = uphi(r)
%o A080768         if v in uphi_level_sets:
%o A080768             for s in uphi_level_sets[v]:
%o A080768                 k, rem = divmod(r*s, v*(r-s))
%o A080768                 if rem == 0:
%o A080768                     yield k
%o A080768         else:
%o A080768             uphi_level_sets[v] = []
%o A080768         uphi_level_sets[v].append(r)
%o A080768 print(list(islice(agen(), 25))) # _Michael S. Branicky_, Sep 30 2025
%Y A080768 Cf. A047994, A080766, A080767, A067739, A067741.
%K A080768 nonn
%O A080768 1,1
%A A080768 _Yasutoshi Kohmoto_
%E A080768 Kohmoto found 2nd, 6th, 13th, 25th terms. _Dean Hickerson_ calculated the other terms.
%E A080768 Offset corrected and ordering defined by _Sean A. Irvine_, Sep 29 2025
%E A080768 a(31) and beyond from _Michael S. Branicky_, Sep 29 2025
