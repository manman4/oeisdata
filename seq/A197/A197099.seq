%I A197099 #42 Sep 22 2025 16:01:08
%S A197099 1,2,4,32,48,180,189,224,288,360,432,1280,1344,1536,1600,4096,28672,
%T A197099 46656,54000,108000,131220,150528,225792,262440,405450,442800,525312,
%U A197099 532480,590400,594000,630784,633600,655360,792000,819200,885600,950400
%N A197099 Define the array k(n,x) = number of m such that tau(gcd(n,m)) is x where m runs from 1 to n. Also define h(n,x) = Sum_{d|n : tau(d) = x} d. The sequence contains numbers n such that k(n,x)*x = h(n,x) has at least one solution x.
%C A197099 In the definition tau=A000005. By construction of the two arrays, their row sums and/or first moments are Sum_{x=1..z} k(x)*x = Sum_{x=1..z} h(x) = sigma(n) = A000203(n).
%C A197099 From _R. J. Mathar_, Oct 12 2011: (Start)
%C A197099 The table k(n,x) with row sums n is a frequency distribution of tau which starts in row n=1 with columns x >= 1 as follows:
%C A197099    1,  0,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  1,  0,  0,  0,  0,  0,  0, ...
%C A197099    2,  1,  0,  0,  0,  0,  0,  0, ...
%C A197099    2,  1,  1,  0,  0,  0,  0,  0, ...
%C A197099    4,  1,  0,  0,  0,  0,  0,  0, ...
%C A197099    2,  3,  0,  1,  0,  0,  0,  0, ...
%C A197099    6,  1,  0,  0,  0,  0,  0,  0, ...
%C A197099    4,  2,  1,  1,  0,  0,  0,  0, ...
%C A197099    6,  2,  1,  0,  0,  0,  0,  0, ...
%C A197099    4,  5,  0,  1,  0,  0,  0,  0, ...
%C A197099   10,  1,  0,  0,  0,  0,  0,  0, ...
%C A197099    4,  4,  2,  1,  0,  1,  0,  0, ...
%C A197099 By multiplying with the column number x we obtain another array x*k(n,x) which has row sums sigma(n):
%C A197099    1,  0,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  2,  0,  0,  0,  0,  0,  0, ...
%C A197099    2,  2,  0,  0,  0,  0,  0,  0, ...
%C A197099    2,  2,  3,  0,  0,  0,  0,  0. ...
%C A197099    4,  2,  0,  0,  0,  0,  0,  0, ...
%C A197099    2,  6,  0,  4,  0,  0,  0,  0, ...
%C A197099    6,  2,  0,  0,  0,  0,  0,  0, ...
%C A197099    4,  4,  3,  4,  0,  0,  0,  0, ...
%C A197099    6,  4,  3,  0,  0,  0,  0,  0, ...
%C A197099    4, 10,  0,  4,  0,  0,  0,  0, ...
%C A197099   10,  2,  0,  0,  0,  0,  0,  0, ...
%C A197099    4,  8,  6,  4,  0,  6,  0,  0, ...
%C A197099 The array h(n,x) with another frequency distribution of tau and also rows sums sigma(n) starts in row n=1 as follows:
%C A197099    1,  0,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  2,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  3,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  2,  4,  0,  0,  0,  0,  0, ...
%C A197099    1,  5,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  5,  0,  6,  0,  0,  0,  0, ...
%C A197099    1,  7,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  2,  4,  8,  0,  0,  0,  0, ...
%C A197099    1,  3,  9,  0,  0,  0,  0,  0, ...
%C A197099    1,  7,  0, 10,  0,  0,  0,  0, ...
%C A197099    1, 11,  0,  0,  0,  0,  0,  0, ...
%C A197099    1,  5,  4,  6,  0, 12,  0,  0, ...
%C A197099 Whenever the previous two tables match at one position (n,x) for a nonzero entry, we add the corresponding row number n to the sequence. The rows at n=4, (2,2,3) and (1,2,4) for example, match at x=2, which adds n=4 to the sequence. (End)
%e A197099 For n = 189: 21|189, 27|189 and tau(21) = tau(27) = 4; h(4) = Sum_{d|189; tau(d) = 4} d = 21+27 = k(4)*4 = 12*4 = 48. Therefore 189 is in the sequence.
%p A197099 k := proc(n,x)
%p A197099         a := 0 ;
%p A197099         for m from 1 to n do
%p A197099                 if numtheory[tau](igcd(n,m)) = x then
%p A197099                         a := a+1 ;
%p A197099                 end if;
%p A197099         end do;
%p A197099         a ;
%p A197099 end proc:
%p A197099 h := proc(n,x)
%p A197099         a := 0 ;
%p A197099         for d in numtheory[divisors](n) do
%p A197099                 if numtheory[tau](d) = x then
%p A197099                         a := a+d ;
%p A197099                 end if;
%p A197099         end do;
%p A197099         a ;
%p A197099 end proc:
%p A197099 isA197099 := proc(n)
%p A197099         for x from 1 to n do
%p A197099                 if h(n,x) = x*k(n,x) and h(n,x) <> 0 then
%p A197099                         return true;
%p A197099                 end if;
%p A197099         end do:
%p A197099         false;
%p A197099 end proc:
%p A197099 for n from 1 do
%p A197099         if isA197099(n) then
%p A197099                 print(n);
%p A197099         end if;
%p A197099 end do: # _R. J. Mathar_, Oct 12 2011
%t A197099 k[n_, x_] := Module[{a = 0}, For[m = 1, m <= n, m++, If[DivisorSigma[0, GCD[n, m]] == x, a++]]; a];
%t A197099 h[n_, x_] := Module[{a = 0}, Do[If[DivisorSigma[0, d] == x, a += d], {d, Divisors[n]}]; a];
%t A197099 isA197099[n_] := For[x = 1, x <= n, x++, If[h[n, x] == x*k[n, x] && h[n, x] != 0, Return[True]]; False];
%t A197099 Reap[For[n = 1, n <= 1000, n++, If[isA197099[n], Print[n]; Sow[n]]]][[2, 1]] (* _Jean-FranÃ§ois Alcover_, Jun 07 2024, after _R. J. Mathar_ *)
%o A197099 (SageMath)
%o A197099 def is_A197099(n): # extremely inefficient but useful for reference purposes
%o A197099     k = lambda x: sum(1 for m in (1..n) if number_of_divisors(gcd(n,m))==x)
%o A197099     h = lambda x: sum(d for d in divisors(n) if number_of_divisors(d)==x)
%o A197099     h_values = ((x, h(x)) for x in range(1, n + 1))
%o A197099     return any(hx != 0 and hx % x == 0 and hx == x*k(x) for x, hx in h_values)
%o A197099 [n for n in range(267) if is_A197099(n)]
%o A197099 # _D. S. McNeil_, Oct 12 2011
%K A197099 nonn
%O A197099 1,2
%A A197099 _Naohiro Nomoto_, Oct 10 2011
