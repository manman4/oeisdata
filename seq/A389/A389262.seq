%I A389262 #92 Oct 15 2025 16:45:02
%S A389262 1,2,2,3,3,4,5,5,6,6,7,8,8,9,9,10,11,11,12,12,13,14,14,15,15,16,17,17,
%T A389262 18,18,19,20,20,21,22,22,23,23,24,25,25,26,26,27,28,28,29,29,30,31,31,
%U A389262 32,32,33,34,34,35,35,36,37,37,38,39,39,40,40,41,42,42
%N A389262 Least k such that more than half the permutations of n elements have longest cycle <= k.
%C A389262 a(n) is the least k such that A330858(n,k) > n!/2.
%C A389262 For the "100 Prisoners Problem" with n participants using the loop (cycle) strategy, a(n) is the minimal number of choices per prisoner required for the overall survival probability to exceed 1/2, defining the critical survival threshold at which collective success becomes more likely than failure.
%H A389262 Gergely Földvári, <a href="/A389262/a389262_1.jpg">Illustrated analysis with first 100 terms</a>
%H A389262 Solomon W. Golomb, Peter Gaal, <a href="https://www.sciencedirect.com/science/article/pii/S0196885897905674">On the Number of Permutations on n Objects with Greatest Cycle Length k</a>, Advances In Applied Mathematics, Volume 20, Issue 1, January 1988, Pages 98-107, for "probability that longest cycle has relative length >=1/2", pls. see p. 106.
%H A389262 Wikipedia, <a href="https://en.wikipedia.org/wiki/100_prisoners_problem">100 prisoners problem</a>.
%F A389262 a(n) = least k >= 1 such that [x^n] exp(Sum_{j=1..k} x^j/j) > 1/2, n >= 1.
%e A389262 a(1) = 1 because 1/1! = 1 = 100%, which already exceeds 1/2.
%e A389262 a(2) = 2 because 1/2! = 1/2 for k<=1; with k<=2, 2/2 = 1 > 1/2.
%e A389262 a(3) = 2 because 1/3! < 1/2 for k<=1; with k<=2, 4/6 > 1/2.
%e A389262 a(4) = 3 because 10/4! < 1/2 for k<=2; with k<=3, 15/24 > 1/2.
%e A389262 a(5) = 3 because, as a fraction of the total number of permutations (5!), the 26 possible permutations with cycle length k<=2 (involutions) still fall below the majority (>1/2) threshold (26/5!=26/120=13/60=0.21666... or 21.7%), whereas the number of possible permutations with cycle length k<=3 already rise above it (66/120=11/20=0.55 or 55%).
%o A389262 (Python)
%o A389262 from math import comb
%o A389262 # Dynamic integer factorials
%o A389262 factorials = [1]  # factorials[n] = n!
%o A389262 def fact(n):
%o A389262     while len(factorials) <= n:
%o A389262         factorials.append(factorials[-1] * len(factorials))
%o A389262     return factorials[n]
%o A389262 # Correct A068424 factor for the recurrence
%o A389262 # A068424(n, k) = binomial(n, k) * k!
%o A389262 def A068424(n, k):
%o A389262     if k == 0:
%o A389262         return 0
%o A389262     return comb(n, k) * fact(k)
%o A389262 # Memoized function to calculate P(n, k) via single recurrence
%o A389262 def P(n, k, memo):
%o A389262     if k >= n:
%o A389262         return fact(n)
%o A389262     if n == 0:
%o A389262         return 1
%o A389262     if (n, k) in memo:
%o A389262         return memo[(n, k)]
%o A389262     # recurrence
%o A389262     result = n * P(n - 1, k, memo) - P(n - k - 1, k, memo) * A068424(n - 1, k)
%o A389262     memo[(n, k)] = result
%o A389262     return result
%o A389262 # Generator of sequence a(n)
%o A389262 def generate_a():
%o A389262     n = 1
%o A389262     memo = {}
%o A389262     while True:
%o A389262         nf = fact(n)
%o A389262         for k in range(1, n + 1):
%o A389262             if P(n, k, memo) > nf // 2:  # exact integer comparison
%o A389262                 yield k
%o A389262                 break
%o A389262         n += 1
%o A389262 # Example: first 610 terms
%o A389262 gen = generate_a()
%o A389262 seq = [next(gen) for _ in range(610)]
%o A389262 print(seq)
%Y A389262 Cf. A000142, A330858, A068424.
%K A389262 nonn,new
%O A389262 1,2
%A A389262 _Gergely Földvári_, Sep 27 2025
