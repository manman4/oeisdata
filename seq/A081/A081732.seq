%I A081732 #19 Oct 07 2025 21:29:39
%S A081732 4,6,6,11,10,11,11,11,10,14,15,15,15,14,15,16,16,15,14,15,15,16,15,16,
%T A081732 15,15,14,18,19,19,20,19,20,20,20,19,19,20,20,19,18,19,20,20,19,20,21,
%U A081732 21,21,20,21,20,20,19,18,19,19,20,19,20,20,20,19,20,21,21,20,19,20,21
%N A081732 Number of numbers that differ from n in ternary representation by exactly one edit-operation: deletion, insertion, or substitution.
%C A081732 a(n) = #{j: LD-3(n,j)=1}, where LD-3 is the Levenshtein distance on ternary strings.
%H A081732 Zhuorui He, <a href="/A081732/b081732.txt">Table of n, a(n) for n = 0..10000</a>
%H A081732 Michael Gilleland, <a href="http://www.merriampark.com/ld.htm">Levenshtein Distance</a>. [It has been suggested that this algorithm gives incorrect results sometimes. - _N. J. A. Sloane_]
%F A081732 From _Zhuorui He_, Oct 01 2025: (Start)
%F A081732 Conjecture: For m >= 3,
%F A081732 a(9m) = a(3m) + 4, a(9m+1) = a(3m) + 5, a(9m+2) = a(3m) + 5,
%F A081732 a(9m+3) = a(3m+1) + 5, a(9m+4) = a(3m+1) + 4, a(9m+5) = a(3m+1) + 5,
%F A081732 a(9m+6) = a(3m+2) + 5, a(9m+7) = a(3m+2) + 5, a(9m+8) = a(3m+2) + 4. (End)
%e A081732 n=12: ternary representation of numbers at Levenshtein distance 1 from 12='110': {10, 11, 100, 111, 112, 120, 210, 1010, 1100, 1101, 1102, 1110, 1120, 1210, 2110}, therefore a(12)=15.
%e A081732 n=42: ternary representation of numbers at Levenshtein distance 1 from 42='1120': {110, 112, 120, 1020, 1100, 1110, 1121, 1122, 1220, 2120, 10120, 11020, 11120, 11200, 11201, 11202, 11210, 11220, 12120, 21120}, therefore a(42)=20.
%o A081732 (Python)
%o A081732 # please run pip install numpy python-baseconv before running this code
%o A081732 import numpy
%o A081732 import baseconv
%o A081732 def A081732(n):
%o A081732   def is_valid(m):
%o A081732     return m[0] != "0" or len(m) == 1
%o A081732   n = baseconv.BaseConverter('012').encode(n)
%o A081732   arr = []
%o A081732   len_n = len(n)
%o A081732   # Deletion
%o A081732   if len_n > 1:
%o A081732     for i in range(len_n):
%o A081732       if is_valid(n[:i]+n[(i+1):]):
%o A081732         arr.append(int(n[:i]+n[(i+1):],3))
%o A081732   # Insertion
%o A081732   for i in range(len_n+1):
%o A081732     for j in range(3):
%o A081732       if is_valid(n[:i]+str(j)+n[i:]):
%o A081732         arr.append(int(n[:i]+str(j)+n[i:],3))
%o A081732   # Substitution
%o A081732   for i in range(len_n):
%o A081732     for j in range(3):
%o A081732       if is_valid(n[:i]+str(j)+n[(i+1):]):
%o A081732         arr.append(int(n[:i]+str(j)+n[(i+1):],3))
%o A081732   return len(numpy.unique(arr)) - 1 # _Zhuorui He_, Oct 01 2025
%Y A081732 Cf. A080950, A080910, A007089.
%K A081732 nonn,base,changed
%O A081732 0,1
%A A081732 _Reinhard Zumkeller_, Apr 06 2003
