%I A387862 #11 Sep 15 2025 00:59:15
%S A387862 0,1,-1,1,-2,0,1,-3,0,1,-2,1,-5,0,1,-1,-2,1,-6,0,1,-7,0,1,-2,-2,1,-8,
%T A387862 0,1,-3,1,1,0,-10,0,1,-10,0,1,-4,-2,1,-11,0,1,2,-4,1,-5,-2,1,-12,0,1,
%U A387862 -13,0,1,-6,-2,1,9,0,-14,0,1,1,-4,1,-14,0,1,-7,-2,1,16,0,-16,0,1,-15,0,1,4,0
%N A387862 Irregular array, read by rows. Let S be the additive monoid generated by the square roots of positive integers, sorted in increasing order. Row n consists of the coefficients of the minimal polynomial of S(n) over the rationals, in ascending order.
%C A387862 Since each S(k) is an algebraic integer, its minimal polynomial is monic with integer coefficients.
%C A387862 The conjugates of Sum_k b_k * sqrt(c_k) are obtained by changing the signs of any nonempty subset of the terms b_k * sqrt(c_k) where c_k > 1.
%H A387862 Robert Israel, <a href="/A387862/b387862.txt">Table of n, a(n) for n = 1..10572</a> (rows 1 to 1800, flattened)
%e A387862 S(25) = 1 + 2*sqrt(2) has minimal polynomial X^2 - 2*X - 7, so row 25 is [-7, -2, 1].
%e A387862 The first 10 rows are
%e A387862    0,  1;
%e A387862   -1,  1;
%e A387862   -2,  0, 1;
%e A387862   -3,  0, 1;
%e A387862   -2,  1;
%e A387862   -5,  0, 1;
%e A387862   -1, -2, 1;
%e A387862   -6,  0, 1;
%e A387862   -7,  0, 1;
%e A387862   -2, -2, 1.
%p A387862 N:= 5: # for terms before the first appearance of N+1 in S
%p A387862 P[0]:= {0}:
%p A387862 for i from 1 to N do P[i]:= {} od:
%p A387862 for x from 1 to (N+1)^2 do
%p A387862   for i from 0 to N do SP[i]:= {} od:
%p A387862   if not numtheory:-issqrfree(x) then next fi;
%p A387862   for j from 1 to floor((N+1)/sqrt(x)) do
%p A387862     for i from 0 to floor(N +1 - j*sqrt(x)) do
%p A387862       for y in P[i] do
%p A387862         z:= y + j*sqrt(x);
%p A387862         iz:= floor(z);
%p A387862         if iz <= N then SP[iz]:= SP[iz] union {z} fi
%p A387862   od od od;
%p A387862   for i from 0 to N do P[i]:= P[i] union SP[i] od;
%p A387862 od;
%p A387862 for i from 0 to N do
%p A387862   P[i]:= sort(convert(P[i], list), (a, b) -> is(a<b))
%p A387862 od:
%p A387862 PP:= [seq(op(P[i]), i=0..N)]:
%p A387862 g:= proc(t) local p,d,i,X;
%p A387862   p:= evala(Minpoly(t,X));
%p A387862   d:= degree(p,X);
%p A387862   seq(coeff(p,X,i),i=0..d);
%p A387862 end proc:
%p A387862 for i from 1 to nops(PP) do
%p A387862   g(PP[i])
%p A387862 od;
%Y A387862 Cf. A387686.
%K A387862 sign,tabf
%O A387862 1,5
%A A387862 _Robert Israel_, Sep 10 2025
