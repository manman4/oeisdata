%I A387398 #39 Oct 06 2025 23:58:03
%S A387398 1,1,1,5,2,69,1,1,5,1,1,12869,2,5,1,1,69,2,5,1,1,601080389,2,5,2,69,1,
%T A387398 1,5,2,12869,1,1,5,1,1,69,2,5,1,1,1832624140942590533,2,5,2,69,1,1,5,
%U A387398 1,1,12869,2,5,1,1,69,2,5,2,601080389,1,1,5,2,69,1,1,5,2,12869,1,1,5,1,1,69,2,5,1,1
%N A387398 Continued fraction expansion of Sum_{k>=0} 1/(2^k)!.
%C A387398 This simple continued fraction exhibits the only known self-describing pattern obtained from the regular paperfolding sequence (A014577) within it. The small digits 1 and 2 follow Cloitre's self-generating, self-describing sequence (A157196).
%C A387398 Meanwhile the large peaks are exactly binomial(2^(k+1), 2^k) - 1, placed by the ruler function A001511, cleanly linking automata-style paper-folding with the explicit peak calculus of strong Engel/Pierce series.
%C A387398 Thanks to the fact that v2((2^(k+1))!/((2^k)!)^2) = 1 for every k (where v2(n) is the exponent of 2 dividing n), we can prove that for S = Sum_{k>=0} 1/(2^k)! the paperfolding order given by Cloitre's self-generating sequence persists at every stage of its continued fraction without perturbation.
%C A387398 A similar continued fraction of a series that exhibits Cloitre's self-generating sequence interleaved within it is Sum_{k>=0} 1/(k!)! (A336810).
%H A387398 Daniel Hoyt, <a href="/A387398/b387398.txt">Table of n, a(n) for n = 0..1000</a>
%H A387398 Daniel Hoyt, <a href="https://doi.org/10.5281/zenodo.16990656">Proof of the continued fraction formula.</a>, Zenodo, 2025.
%H A387398 Jeffrey Shallit, <a href="https://arxiv.org/abs/2501.00784">Cloitre's Self-Generating Sequence</a>, arXiv:2501.00784 [math.CO], 2025.
%F A387398 Let P(k) = binomial(2^(k+1), 2^k) - 1. After the first term 1, the rest of the continued fraction is an interleaving between the n-th runs of '1,1' and '2' in A157196, and P(A001511(n)).
%t A387398 ContinuedFraction[Sum[1/(2^k)!, {k, 0, 6}], 21]
%o A387398 (Python)
%o A387398 import sys #only needed for printing large digits
%o A387398 sys.set_int_max_str_digits(0) #otherwise sys not needed
%o A387398 def a387398(n):
%o A387398     if n < 0: raise ValueError("n>=0")
%o A387398     if n == 0: return 1
%o A387398     import math
%o A387398     s=[1, 1]; h=2; p=0; idx=0; r=1
%o A387398     while True:
%o A387398         while len(s) < p+2:
%o A387398             t = 2 if (h & 1) == 0 else 1
%o A387398             s += [t]*((s[h-1]*2)//t); h += 1
%o A387398         if s[p]==2:
%o A387398             p+=1; idx+=1
%o A387398             if idx==n: return 2
%o A387398             K=((r & -r).bit_length()-1)+1
%o A387398             idx+=1
%o A387398             if idx==n: return math.comb(1<<(K+1), 1<<K)-1
%o A387398         elif p+1<len(s) and s[p]==1 and s[p+1]==1:
%o A387398             p+=2; idx+=1
%o A387398             if idx==n: return 1
%o A387398             idx+=1
%o A387398             if idx==n: return 1
%o A387398             K=((r & -r).bit_length()-1)+1
%o A387398             idx+=1
%o A387398             if idx==n: return math.comb(1<<(K+1), 1<<K)-1
%o A387398         else:
%o A387398             continue
%o A387398         r+=1
%Y A387398 Cf. A001511, A157196, A014577, A336810, A386384.
%Y A387398 Cf. A387399 (decimal expansion).
%K A387398 nonn,cofr
%O A387398 0,4
%A A387398 _Daniel Hoyt_, Aug 28 2025
