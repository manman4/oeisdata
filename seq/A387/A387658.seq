%I A387658 #23 Sep 16 2025 22:23:27
%S A387658 2,10,16,8,10,32,24,0,16,34,32,24,8,32,48,0,10,56,40,24,32,48,24,0,24,
%T A387658 42,80,32,0,80,48,0,16,48,56,48,34,32,72,0,32,104,48,24,24,80,48,0,8,
%U A387658 58,96,48,32,80,96,0,48,48,32,72,0,80,96,0,10,112,96,24,56,96,48
%N A387658 Number of points on a cubic lattice that have a minimum distance sqrt(n) from either of two adjacent lattice points.
%H A387658 Sean A. Irvine, <a href="/A387658/b387658.txt">Table of n, a(n) for n = 0..10000</a>
%F A387658 a(n) = A004018(n) + A005875(n). - _Sean A. Irvine_, Sep 11 2025
%F A387658 a(n) = 2*Sum_{i=0..floor(sqrt(n))} A004018(n-i^2). - _Chai Wah Wu_, Sep 13 2025
%e A387658 Given points (0, 0, 0) and (1, 0, 0), the ten points (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1), (1, 1, 0), (1, -1, 0), (1, 0, 1), (1, 0, -1), and (2, 0, 0) are all distance sqrt(1), from one or other of those points.
%o A387658 (MATLAB)
%o A387658 targ=3; %or whatever target you want
%o A387658 N=0;
%o A387658 A=[0 0 0];
%o A387658 B=[1 0 0];
%o A387658 rango=targ+2;
%o A387658 rangi=-rango:rango;
%o A387658 for i=rangi
%o A387658     for j=rangi
%o A387658         for k=rangi
%o A387658             R=[i j k];
%o A387658             d1=sum((R-A).^2);
%o A387658             d2=sum((R-B).^2);
%o A387658                 if ((d1==targ) || (d2==targ)) && min(d1,d2)>targ-1
%o A387658                      N=N+1;
%o A387658                 end
%o A387658         end
%o A387658     end
%o A387658 end
%o A387658 (Python)
%o A387658 from math import prod, isqrt
%o A387658 from sympy import factorint
%o A387658 def A004018(n): return prod(1 if p==2 else (e+1 if p&3==1 else (e+1)&1) for p, e in factorint(n).items())<<2 if n else 1
%o A387658 def A387658(n): return sum(A004018(n-k**2) for k in range(isqrt(n)+1))<<1 # _Chai Wah Wu_, Sep 13 2025
%Y A387658 Cf. A004018, A005875, A004215.
%K A387658 nonn
%O A387658 0,1
%A A387658 _Alex Klotz_, Sep 05 2025
