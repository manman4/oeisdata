%I A387866 #40 Sep 23 2025 04:32:40
%S A387866 11,22,33,44,55,66,77,88,99,100,111,122,133,144,155,166,177,188,199,
%T A387866 200,212,221,224,236,248,300,313,326,331,339,400,414,422,428,441,500,
%U A387866 515,551,600,616,623,632,661,700,717,771,800,818,824,842,881,900,919,933,991,1000
%N A387866 Numbers that can be split into two numbers whose products of digits are equal.
%C A387866 Leading zeros are allowed only for the second number, e.g., 1001 split into 10 and 01.
%C A387866 Numbers with more than 1 decimal digit '0' are terms. - _Chai Wah Wu_, Sep 17 2025
%H A387866 Robert Israel, <a href="/A387866/b387866.txt">Table of n, a(n) for n = 1..10000</a>
%e A387866 221 is a term since A007954(2) = A007954(21);
%e A387866 1001 is a term since A007954(10) = A007954(01);
%e A387866 1050 is a term since A007954(10) = A007954(50);
%e A387866 14224 is a term since A007954(142) = A007954(24).
%p A387866 filter:= proc(n) local L,i;
%p A387866   L:= convert(n,base,10);
%p A387866   ormap(i -> convert(L[1..i],`*`) = convert(L[i+1..-1],`*`), [$1..nops(L)-1])
%p A387866 end proc:
%p A387866 select(filter, [$10 .. 2000]); # _Robert Israel_, Sep 18 2025
%t A387866 Select[Range[1000],Sum[Boole[Product[Part[(digits=IntegerDigits[#]),i],{i,k}]==Product[Part[digits,i],{i,k+1,IntegerLength[#]}]],{k,IntegerLength[#]-1}]>0 &]
%o A387866 (Python)
%o A387866 from math import prod
%o A387866 def ok(n):
%o A387866     d = list(map(int, str(n)))
%o A387866     return any(prod(d[:i]) == prod(d[i:]) for i in range(1, len(d)))
%o A387866 print([k for k in range(1001) if ok(k)]) # _Michael S. Branicky_, Sep 12 2025
%o A387866 (PARI) isok(k) = my(d=digits(k)); for (i=2, #d, if (prod(j=1, i-1, d[j]) == prod(j=i, #d, d[j]), return(1));); \\ _Michel Marcus_, Sep 12 2025
%Y A387866 Cf. A007954, A067042, A083967, A238237, A387867.
%K A387866 nonn,base,easy
%O A387866 1,1
%A A387866 _Stefano Spezia_, Sep 10 2025
